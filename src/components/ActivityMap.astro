---
export interface Props {
  activities?: Array<{
    id: string;
    name: string;
    type: string;
    distance: number;
    moving_time: number;
    start_date_local: string;
    map?: {
      summary_polyline?: string;
    };
    start_latlng?: [number, number];
  }>;
  height?: string;
}

const {
  activities = [],
  height = "400px"
} = Astro.props;

// Filter activities that have location data
const activitiesWithLocation = activities.filter(activity =>
  activity.start_latlng && activity.start_latlng.length === 2
);

const hasMapData = activitiesWithLocation.length > 0;
---

<div class="activity-map-container">
  <!-- Map Header -->
  <div class="map-header">
    <div class="flex items-center justify-between text-xs mb-3">
      <div class="flex items-center space-x-3">
        <span class="text-green-400 animate-pulse">[GEOSPATIAL_ANALYSIS]</span>
        <div class="flex items-center space-x-1">
          <div class="w-1 h-1 bg-green-500 rounded-full animate-pulse"></div>
          <span class="text-green-500">GPS_TRACKING</span>
        </div>
      </div>
      <div class="text-green-300">
        <span class="text-green-400/60">ACTIVITIES:</span>
        <span class="ml-1">{activitiesWithLocation.length}</span>
      </div>
    </div>

    <div class="terminal-separator mb-4"></div>
  </div>

  <!-- Map Container -->
  <div class="map-wrapper" style={`height: ${height}`}>
    {hasMapData ? (
      <div
        id="activity-map"
        class="w-full h-full rounded border border-green-500/30"
        data-activities={JSON.stringify(activitiesWithLocation)}
      ></div>
    ) : (
      <div class="map-placeholder">
        <div class="text-center text-green-400/60">
          <div class="text-2xl mb-2">⚠</div>
          <div class="text-sm">[NO_GPS_DATA_AVAILABLE]</div>
          <div class="text-xs mt-1 text-green-500/50">
            Enable GPS tracking in Strava to view map data
          </div>
        </div>
      </div>
    )}
  </div>

  <!-- Map Legend/Controls -->
  {hasMapData && (
    <div class="map-controls mt-4">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs">
        <div class="control-group">
          <span class="text-green-400/60">MAP_MODE:</span>
          <select id="map-style-selector" class="matrix-select ml-2">
            <option value="satellite">SATELLITE</option>
            <option value="terrain">TERRAIN</option>
            <option value="standard">STANDARD</option>
          </select>
        </div>
        <div class="control-group">
          <span class="text-green-400/60">ACTIVITY_FILTER:</span>
          <select id="activity-filter" class="matrix-select ml-2">
            <option value="all">ALL_TYPES</option>
            <option value="Run">RUN</option>
            <option value="Ride">CYCLING</option>
            <option value="Walk">WALK</option>
          </select>
        </div>
        <div class="control-group">
          <button id="reset-view" class="matrix-button">
            [RESET_VIEW]
          </button>
        </div>
      </div>
    </div>
  )}
</div>

<style>
  .activity-map-container {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(0, 20, 0, 0.7) 100%);
    border: 1px solid rgba(0, 255, 0, 0.3);
    border-radius: 8px;
    padding: 20px;
    box-shadow:
      0 0 20px rgba(0, 255, 0, 0.2),
      inset 0 0 20px rgba(0, 255, 0, 0.05);
    position: relative;
  }

  .activity-map-container::before {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: 9px;
    padding: 1px;
    background: linear-gradient(45deg,
      rgba(0, 255, 0, 0.4),
      transparent,
      rgba(0, 255, 0, 0.4)
    );
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: xor;
    animation: mapBorderGlow 4s ease-in-out infinite;
  }

  @keyframes mapBorderGlow {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.8; }
  }

  .map-header {
    font-family: 'Courier New', monospace;
  }

  .terminal-separator {
    height: 1px;
    background: linear-gradient(90deg,
      transparent,
      rgba(0, 255, 0, 0.5),
      transparent
    );
    animation: separatorGlow 2s ease-in-out infinite alternate;
  }

  @keyframes separatorGlow {
    0% { opacity: 0.3; }
    100% { opacity: 0.8; }
  }

  .map-wrapper {
    position: relative;
    overflow: hidden;
    border-radius: 6px;
  }

  .map-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    border: 1px dashed rgba(0, 255, 0, 0.3);
    border-radius: 6px;
    font-family: 'Courier New', monospace;
  }

  .map-controls {
    font-family: 'Courier New', monospace;
  }

  .control-group {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: rgba(0, 255, 0, 0.05);
    border: 1px solid rgba(0, 255, 0, 0.1);
    border-radius: 4px;
  }

  .matrix-select {
    background: rgba(0, 0, 0, 0.8);
    color: #00ff00;
    border: 1px solid rgba(0, 255, 0, 0.3);
    border-radius: 3px;
    padding: 2px 6px;
    font-size: 0.75rem;
    font-family: 'Courier New', monospace;
    outline: none;
  }

  .matrix-select:focus {
    border-color: rgba(0, 255, 0, 0.6);
    box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
  }

  .matrix-button {
    background: rgba(0, 255, 0, 0.1);
    color: #00ff00;
    border: 1px solid rgba(0, 255, 0, 0.3);
    border-radius: 3px;
    padding: 4px 8px;
    font-size: 0.75rem;
    font-family: 'Courier New', monospace;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .matrix-button:hover {
    background: rgba(0, 255, 0, 0.2);
    border-color: rgba(0, 255, 0, 0.6);
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.3);
  }

  /* Leaflet Map Customization */
  :global(.leaflet-container) {
    background: #000 !important;
    font-family: 'Courier New', monospace !important;
  }

  :global(.leaflet-popup-content-wrapper) {
    background: rgba(0, 0, 0, 0.95) !important;
    color: #00ff00 !important;
    border: 1px solid rgba(0, 255, 0, 0.5) !important;
    border-radius: 4px !important;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.3) !important;
  }

  :global(.leaflet-popup-content) {
    margin: 8px 12px !important;
    font-family: 'Courier New', monospace !important;
    font-size: 0.75rem !important;
  }

  :global(.leaflet-popup-tip) {
    background: rgba(0, 0, 0, 0.95) !important;
    border: 1px solid rgba(0, 255, 0, 0.5) !important;
  }

  :global(.leaflet-control-zoom) {
    background: rgba(0, 0, 0, 0.8) !important;
    border: 1px solid rgba(0, 255, 0, 0.3) !important;
    border-radius: 4px !important;
  }

  :global(.leaflet-control-zoom a) {
    background: rgba(0, 0, 0, 0.9) !important;
    color: #00ff00 !important;
    border-bottom: 1px solid rgba(0, 255, 0, 0.2) !important;
    font-weight: bold !important;
  }

  :global(.leaflet-control-zoom a:hover) {
    background: rgba(0, 255, 0, 0.1) !important;
    color: #00ff00 !important;
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .activity-map-container {
      padding: 16px;
    }

    .map-controls .grid {
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .control-group {
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
    }

    .matrix-select, .matrix-button {
      width: 100%;
    }
  }
</style>

<script>
  import L from 'https://unpkg.com/leaflet@1.9.4/dist/leaflet-src.esm.js';

  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', function() {
    const mapElement = document.getElementById('activity-map');
    if (!mapElement) return;

    const activitiesData = JSON.parse(mapElement.dataset.activities || '[]');
    if (activitiesData.length === 0) return;

    // Initialize map
    const map = L.map('activity-map', {
      zoomControl: true,
      scrollWheelZoom: true,
      doubleClickZoom: true,
      dragging: true
    });

    // Add tile layers
    const tileLayers = {
      standard: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors',
        maxZoom: 18
      }),
      satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '© Esri',
        maxZoom: 18
      }),
      terrain: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenTopoMap contributors',
        maxZoom: 17
      })
    };

    // Set initial layer
    tileLayers.satellite.addTo(map);
    let currentLayer = 'satellite';

    // Store markers and polylines for filtering
    const markers = [];
    const polylines = [];
    const markerGroup = L.layerGroup().addTo(map);
    const polylineGroup = L.layerGroup().addTo(map);

    // Activity type colors
    const activityColors = {
      'Run': '#ff0040',
      'Ride': '#0066ff',
      'Walk': '#00ff00',
      'Hike': '#ff8800',
      'default': '#00ff00'
    };

    // Function to decode polyline (simplified version)
    function decodePolyline(str, precision = 5) {
      let index = 0;
      let lat = 0;
      let lng = 0;
      let coordinates = [];
      let shift = 0;
      let result = 0;
      let byte = null;
      let latitude_change, longitude_change;
      let factor = Math.pow(10, precision);

      while (index < str.length) {
        byte = null;
        shift = 0;
        result = 0;

        do {
          byte = str.charCodeAt(index++) - 63;
          result |= (byte & 0x1f) << shift;
          shift += 5;
        } while (byte >= 0x20);

        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        shift = result = 0;

        do {
          byte = str.charCodeAt(index++) - 63;
          result |= (byte & 0x1f) << shift;
          shift += 5;
        } while (byte >= 0x20);

        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        lat += latitude_change;
        lng += longitude_change;

        coordinates.push([lat / factor, lng / factor]);
      }

      return coordinates;
    }

    // Add activities to map
    function addActivitiesToMap(activities) {
      // Clear existing markers and polylines
      markerGroup.clearLayers();
      polylineGroup.clearLayers();
      markers.length = 0;
      polylines.length = 0;

      const bounds = L.latLngBounds();

      activities.forEach(activity => {
        const color = activityColors[activity.type] || activityColors.default;

        // Add start marker
        if (activity.start_latlng) {
          const marker = L.circleMarker(activity.start_latlng, {
            radius: 6,
            fillColor: color,
            color: color,
            weight: 2,
            opacity: 0.8,
            fillOpacity: 0.6
          });

          const popupContent = `
            <div class="text-green-400">
              <div class="font-bold mb-1">[${activity.type.toUpperCase()}]</div>
              <div class="text-xs space-y-1">
                <div><span class="text-green-500">NAME:</span> ${activity.name}</div>
                <div><span class="text-green-500">DISTANCE:</span> ${(activity.distance / 1000).toFixed(2)} km</div>
                <div><span class="text-green-500">TIME:</span> ${Math.floor(activity.moving_time / 60)} min</div>
                <div><span class="text-green-500">DATE:</span> ${new Date(activity.start_date_local).toLocaleDateString()}</div>
              </div>
            </div>
          `;

          marker.bindPopup(popupContent);
          marker.activityType = activity.type;
          markers.push(marker);
          markerGroup.addLayer(marker);
          bounds.extend(activity.start_latlng);
        }

        // Add polyline if available
        if (activity.map && activity.map.summary_polyline) {
          try {
            const coordinates = decodePolyline(activity.map.summary_polyline);
            const polyline = L.polyline(coordinates, {
              color: color,
              weight: 3,
              opacity: 0.7,
              smoothFactor: 1
            });

            polyline.activityType = activity.type;
            polylines.push(polyline);
            polylineGroup.addLayer(polyline);
            bounds.extend(coordinates);
          } catch (error) {
            console.log('Error decoding polyline:', error);
          }
        }
      });

      // Fit map to bounds
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    // Filter activities by type
    function filterActivities(type) {
      markers.forEach(marker => {
        if (type === 'all' || marker.activityType === type) {
          markerGroup.addLayer(marker);
        } else {
          markerGroup.removeLayer(marker);
        }
      });

      polylines.forEach(polyline => {
        if (type === 'all' || polyline.activityType === type) {
          polylineGroup.addLayer(polyline);
        } else {
          polylineGroup.removeLayer(polyline);
        }
      });
    }

    // Initial load
    addActivitiesToMap(activitiesData);

    // Map style selector
    const styleSelector = document.getElementById('map-style-selector');
    if (styleSelector) {
      styleSelector.addEventListener('change', function(e) {
        const newStyle = e.target.value;
        if (currentLayer !== newStyle && tileLayers[newStyle]) {
          map.removeLayer(tileLayers[currentLayer]);
          tileLayers[newStyle].addTo(map);
          currentLayer = newStyle;
        }
      });
    }

    // Activity filter
    const activityFilter = document.getElementById('activity-filter');
    if (activityFilter) {
      activityFilter.addEventListener('change', function(e) {
        filterActivities(e.target.value);
      });
    }

    // Reset view button
    const resetButton = document.getElementById('reset-view');
    if (resetButton) {
      resetButton.addEventListener('click', function() {
        addActivitiesToMap(activitiesData);
      });
    }
  });
</script>

<!-- Leaflet CSS -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>