---
import type { StravaActivity } from '@services/stravaService';

// Props interface defines what data the component expects.
// `activities` should be an array of StravaActivity objects.
// `height` is an optional string to set the map's height.
export interface Props {
  activities: StravaActivity[]; // Ensure this matches the type from stravaService.ts
  height?: string;
}

// Destructure props with default values.
const { activities, height = '500px' } = Astro.props;

// Generate a unique ID for the map div. This is crucial if multiple maps
// could appear on the same page, preventing ID collisions.
const mapId = `leaflet-map-${Math.random().toString(36).substring(2, 9)}`;
---

<!-- Leaflet CSS: Fetches the necessary stylesheet for Leaflet from a CDN. -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

<!-- Leaflet JavaScript: Fetches the Leaflet library from a CDN.
     `is:inline` tells Astro to inline this script, ensuring `L` (Leaflet global)
     is available when the component's main script runs. -->
<script is:inline src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<!-- Map Container Div: This is where the Leaflet map will be rendered.
     The `id` is dynamic (using `mapId`) and inline styles set its height and a basic matrix theme. -->
<div
  id={mapId}
  style={`height: ${height}; width: 100%; border: 1px solid rgba(0, 255, 0, 0.3); border-radius: 6px; background: #0D0D0D;`}
  class="map-container-matrix"
  data-map-id={mapId}
  data-activities={JSON.stringify(activities)}
>
  <!-- Fallback/Loading Message: Displayed while the map is initializing or if there's an error. -->
  <p style="color: #00ff00; text-align: center; padding-top: 20px;" class="map-loading-message">Initializing Geospatial Interface...</p>
</div>

<!-- Client-Side Script: This script handles the map initialization and interaction. -->
<script>
  /// <reference types="leaflet" />
  // Explicitly declare the L global variable with its type for TypeScript
  declare var L: typeof import('leaflet');

  // Function to initialize the map
  async function initializeMap(mapContainerElement: HTMLElement) {
    const mapIdFromData = mapContainerElement.dataset.mapId;
    const activitiesString = mapContainerElement.dataset.activities;

    if (!mapIdFromData) {
      console.error('data-map-id attribute is missing or empty on map container.');
      return;
    }

    const mapElement = document.getElementById(mapIdFromData); // Get the actual map div by its ID
    const loadingMessageElement = mapElement?.querySelector('.map-loading-message') as HTMLElement | null;

    // Helper to update loading/error message
    const setMapMessage = (message: string, isError: boolean = false) => {
      if (loadingMessageElement) {
        loadingMessageElement.textContent = message;
        loadingMessageElement.style.color = isError ? 'red' : '#00ff00';
        loadingMessageElement.style.display = 'block';
      }
      if (isError) console.error(message);
    };

    if (!mapElement) {
      setMapMessage(`Critical Error: Map element with ID '${mapIdFromData}' not found.`, true);
      return;
    }

    if (typeof L === 'undefined') {
      setMapMessage('Critical Error: Leaflet library (L) not found. Ensure it is loaded.', true);
      return;
    }

    setMapMessage('Initializing Geospatial Interface...', false);


    let activities: any[] = [];
    try {
      activities = JSON.parse(activitiesString || '[]');
    } catch (e) {
      setMapMessage('Error: Could not parse activity data.', true);
      console.error('Error parsing activities data from data-activities attribute:', e);
      return;
    }

    let polylineDecoder: ((encoded: string) => [number, number][]) | undefined;
    let simplify: ((points: { x: number; y: number }[], tolerance?: number, highestQuality?: boolean) => { x: number; y: number }[]) | undefined;

    try {
      const polylineModule = await import('@mapbox/polyline');
      const decoder = polylineModule.default?.decode || polylineModule.decode;
      if (typeof decoder === 'function') {
        polylineDecoder = decoder;
      } else {
        throw new Error("Polyline library loaded, but 'decode' function is not available or not a function.");
      }

      const simplifyJsModule = await import('simplify-js');
      if (typeof simplifyJsModule.default === 'function') {
        simplify = simplifyJsModule.default;
      } else if (typeof simplifyJsModule === 'function') { // In case simplify-js is not a default export
        simplify = simplifyJsModule;
      }
       else {
        throw new Error("simplify-js library loaded, but the 'simplify' function is not available.");
      }
    } catch (e: any) {
      setMapMessage(`Error: Could not load polyline or simplification library. Polylines may not be drawn or optimized. Details: ${e.message}`, true);
    }

    if (loadingMessageElement) loadingMessageElement.style.display = 'none';

    let initialLat = 20;
    let initialLng = 0;
    let initialZoom = 2;

    const map = L.map(mapIdFromData);
    const featureGroup = L.featureGroup();

    const activityTypeColors = {
      'Run': '#00FF00', 'Ride': '#00FFFF', 'Swim': '#0000FF',
      'Walk': '#FFFF00', 'Hike': '#FFA500', 'Default': '#FF00FF'
    };

    const greenIcon = L.icon({
        iconUrl: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="%2300FF00" width="20" height="20"><path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" /></svg>',
        iconSize: [24, 24], iconAnchor: [12, 24], popupAnchor: [0, -24]
    });

    activities.forEach(activity => {
      let itemAdded = false;
      const popupContent = `<b>${activity.name || 'Unnamed Activity'}</b><br>Type: ${activity.type || activity.sport_type || 'N/A'}`;

      if (polylineDecoder && activity.summary_polyline) {
        try {
          let latlngs = polylineDecoder(activity.summary_polyline);
          if (latlngs && latlngs.length > 0) {
            if (simplify) {
              // Convert [lat, lng] to {x: lng, y: lat} for simplify-js
              const pointsToSimplify = latlngs.map(p => ({ x: p[1], y: p[0] }));
              // Tolerance: smaller values mean less simplification. 0.0001 is a common starting point.
              const simplifiedPoints = simplify(pointsToSimplify, 0.0001, true);
              // Convert simplified points back to [lat, lng] for Leaflet
              latlngs = simplifiedPoints.map(p => [p.y, p.x]);
            }

            const activityType = activity.type || activity.sport_type || 'Default';
            const selectedColor = activityTypeColors[activityType] || activityTypeColors['Default'];
            L.polyline(latlngs, { color: selectedColor, weight: 3, opacity: 0.75 }).addTo(featureGroup)
              .bindPopup(popupContent);
            itemAdded = true;
          }
        } catch (decodeError) {
          console.warn(`Could not decode polyline for activity '${activity.name}': ${decodeError}. Falling back to marker if possible.`);
        }
      }

      if (!itemAdded && activity.start_latlng && activity.start_latlng.length === 2) {
        L.marker([activity.start_latlng[0], activity.start_latlng[1]], { icon: greenIcon }).addTo(featureGroup)
          .bindPopup(popupContent + (activity.summary_polyline ? "<br><small>(Polyline error)</small>" : ""));
        itemAdded = true;
      }

      if (!itemAdded) {
        console.warn(`Activity '${activity.name}' had no summary_polyline or valid start_latlng. It was not added to the map.`);
      }
    });

    if (featureGroup.getLayers().length > 0) {
      featureGroup.addTo(map);
      try {
        map.fitBounds(featureGroup.getBounds(), { padding: [40, 40], maxZoom: 15, animate: true });
      } catch (e) {
        console.warn("fitBounds failed. Setting a default view for activities:", e);
        const firstGpsActivity = activities.find(act => act.start_latlng && act.start_latlng.length === 2);
        if (firstGpsActivity?.start_latlng) {
             map.setView([firstGpsActivity.start_latlng[0], firstGpsActivity.start_latlng[1]], 13);
        } else {
            map.setView([initialLat, initialLng], initialZoom);
        }
      }
    } else {
      map.setView([initialLat, initialLng], initialZoom);
      setMapMessage('No activities with displayable GPS data found.', false);
    }

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer" style="color:#33FF33;">OpenStreetMap</a> contributors',
      className: 'matrix-tile-layer'
    }).addTo(map);

    if (map.zoomControl) {
      const zoomContainer = map.zoomControl.getContainer();
      if (zoomContainer) {
        zoomContainer.classList.add('leaflet-control-zoom-matrix');
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const mapContainers = document.querySelectorAll('.map-container-matrix[data-map-id]') as NodeListOf<HTMLElement>;

    if (mapContainers.length === 0) {
      console.warn('No map containers found on this page.');
      return;
    }

    const observerCallback = (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const mapContainerElement = entry.target as HTMLElement;
          const loadingMessageElement = mapContainerElement.querySelector('.map-loading-message') as HTMLElement | null;
          if (loadingMessageElement) {
            loadingMessageElement.textContent = 'Loading map data...';
          }

          initializeMap(mapContainerElement);
          observer.unobserve(mapContainerElement); // Unobserve after initializing
        }
      });
    };

    const observerOptions = {
      root: null, // relative to document viewport
      rootMargin: '0px',
      threshold: 0.1 // visible amount of item before callback is run
    };

    const observer = new IntersectionObserver(observerCallback, observerOptions);
    mapContainers.forEach(container => {
      const loadingMessageElement = container.querySelector('.map-loading-message') as HTMLElement | null;
      if (loadingMessageElement) {
          loadingMessageElement.textContent = 'Map is waiting to be visible...';
      }
      observer.observe(container);
    });
  });
</script>

<!-- Global Styles for Leaflet elements to match the Matrix theme.
     `is:global` allows these styles to affect Leaflet's dynamically generated HTML. -->
<style is:global>
  .leaflet-popup-content-wrapper,
  .leaflet-popup-tip {
    background: rgba(10, 15, 10, 0.9) !important; /* Dark, slightly transparent green */
    color: #00FF00 !important;
    border: 1px solid rgba(0, 255, 0, 0.7) !important;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.7) !important;
    border-radius: 4px !important;
  }
  .leaflet-popup-content {
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.8rem;
    line-height: 1.4;
  }
  .leaflet-popup-content b { /* Activity Name in Popup */
    color: #88FF88; /* Brighter green for titles */
  }
  .leaflet-popup-content small { /* Subtext in Popup */
    color: #00CC00;
  }
  .leaflet-popup-close-button { /* Close button in popup */
    color: #00FF00 !important;
    background-color: transparent !important;
  }
  .leaflet-popup-close-button:hover {
    color: #FFFFFF !important;
    background-color: #00FF00 !important; /* Green highlight on hover */
  }

  .leaflet-control-attribution { /* Attribution text (bottom-right) */
    background: rgba(0, 10, 0, 0.85) !important;
    color: #00CC00 !important; /* Dim green for less emphasis */
  }
  .leaflet-control-attribution a,
  .leaflet-control-attribution a:hover {
    color: #33FF33 !important; /* Brighter green for links */
  }

  .leaflet-control-zoom-matrix a { /* Zoom control buttons */
    background-color: rgba(10, 15, 10, 0.9) !important;
    color: #00FF00 !important;
    border-color: rgba(0, 255, 0, 0.7) !important;
    border-radius: 3px;
  }
  .leaflet-control-zoom-matrix a:hover {
    background-color: #003300 !important; /* Darker green on hover */
    color: #88FF88 !important;
  }

  .map-container-matrix { /* Ensure the map container itself clips content like border-radius */
    overflow: hidden;
  }

  .map-loading-message { /* Style for the loading/status message inside map div */
    font-family: 'Courier New', Courier, monospace;
    animation: matrixPulseText 1.5s infinite ease-in-out;
  }

  @keyframes matrixPulseText {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* Optional: Styling for map tiles for a more "matrix" feel.
     This can impact performance and readability. Use with caution. */
  .matrix-tile-layer .leaflet-tile {
    filter: invert(1) hue-rotate(180deg) brightness(0.8) contrast(1.2);
  }
</style>
