---
import type { StravaActivity } from '@services/stravaService';

// Props interface defines what data the component expects.
// `activities` should be an array of StravaActivity objects.
// `height` is an optional string to set the map's height.
export interface Props {
  activities: StravaActivity[]; // Ensure this matches the type from stravaService.ts
  height?: string;
}

// Destructure props with default values.
const { activities, height = '500px' } = Astro.props;

// Generate a unique ID for the map div. This is crucial if multiple maps
// could appear on the same page, preventing ID collisions.
const mapId = `leaflet-map-${Math.random().toString(36).substring(2, 9)}`;
---

<!-- Leaflet CSS: Fetches the necessary stylesheet for Leaflet from a CDN. -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

<!-- Leaflet JavaScript: Fetches the Leaflet library from a CDN.
     `is:inline` tells Astro to inline this script, ensuring `L` (Leaflet global)
     is available when the component's main script runs. -->
<script is:inline src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<!-- Map Container Div: This is where the Leaflet map will be rendered.
     The `id` is dynamic (using `mapId`) and inline styles set its height and a basic matrix theme. -->
<div
  id={mapId}
  style={`height: ${height}; width: 100%; border: 1px solid rgba(0, 255, 0, 0.3); border-radius: 6px; background: #0D0D0D;`}
  class="map-container-matrix"
  data-map-id={mapId}
  data-activities={JSON.stringify(activities)}
>
  <!-- Fallback/Loading Message: Displayed while the map is initializing or if there's an error. -->
  <p style="color: #00ff00; text-align: center; padding-top: 20px;" class="map-loading-message">Initializing Geospatial Interface...</p>
</div>

<!-- Client-Side Script: This script handles the map initialization and interaction. -->
<script>
  /// <reference types="leaflet" />
  // Explicitly declare the L global variable with its type for TypeScript
  declare var L: typeof import('leaflet');

  // Event listener ensures the script runs after the DOM is fully loaded.
  document.addEventListener('DOMContentLoaded', async () => {
    // mapId and activities are now read from data attributes
    const mapContainerElement = document.querySelector(`.map-container-matrix[data-map-id]`) as HTMLElement | null;

    if (!mapContainerElement) {
      console.error('Map container element with data-map-id not found.');
      const loadingMessage = document.querySelector('.map-loading-message') as HTMLElement | null;
      if (loadingMessage) loadingMessage.textContent = 'Critical Error: Map container data attributes not found.';
      return;
    }

    const mapIdFromData = mapContainerElement.dataset.mapId;
    const activitiesString = mapContainerElement.dataset.activities;

    if (!mapIdFromData) {
      console.error('data-map-id attribute is missing or empty on map container.');
      return;
    }

    const mapElement = document.getElementById(mapIdFromData); // Get the actual map div by its ID
    const loadingMessageElement = mapElement?.querySelector('.map-loading-message') as HTMLElement | null;

    let activities: any[] = [];
    try {
      activities = JSON.parse(activitiesString || '[]');
    } catch (e) {
      console.error('Error parsing activities data from data-activities attribute:', e);
      if (loadingMessageElement) loadingMessageElement.textContent = 'Error: Could not parse activity data.';
      return;
    }

    // Helper to update loading/error message
    const setMapMessage = (message: string, isError: boolean = false) => {
      if (loadingMessageElement) {
        loadingMessageElement.textContent = message;
        loadingMessageElement.style.color = isError ? 'red' : '#00ff00';
        loadingMessageElement.style.display = 'block';
      }
      if (isError) console.error(message);
    };

    if (!mapElement) {
      // mapIdFromData is used here for the error message
      setMapMessage(`Critical Error: Map element with ID '${mapIdFromData}' not found.`, true);
      return;
    }
    if (typeof L === 'undefined') {
      setMapMessage('Critical Error: Leaflet library (L) not found. Ensure it is loaded.', true);
      return;
    }

    let polylineDecoder: ((encoded: string) => [number, number][]) | undefined; // To store the polyline decoding function
    try {
      // Dynamically import the @mapbox/polyline library.
      const polylineModule = await import('@mapbox/polyline');
      const decoder = polylineModule.default?.decode || polylineModule.decode;
      if (typeof decoder === 'function') {
        polylineDecoder = decoder;
      } else {
        throw new Error("Polyline library loaded, but 'decode' function is not available or not a function.");
      }
    } catch (e: any) {
      setMapMessage(`Error: Could not load polyline decoding library. Polylines will not be drawn. Details: ${e.message}`, true);
      // We can continue without polylines, relying on markers.
    }

    if (loadingMessageElement) loadingMessageElement.style.display = 'none'; // Hide initial loading message

    // Default map view settings (world view)
    let initialLat = 20;
    let initialLng = 0;
    let initialZoom = 2;

    const map = L.map(mapIdFromData); // Initialize the map on the div using ID from data attribute
    const featureGroup = L.featureGroup(); // Group for markers and polylines to easily fit bounds

    // Custom green marker icon, styled for the matrix theme.
    const greenIcon = L.icon({
        iconUrl: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="%2300FF00" width="20" height="20"><path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" /></svg>',
        iconSize: [24, 24], // Slightly larger for better visibility
        iconAnchor: [12, 24],
        popupAnchor: [0, -24]
    });

    // Process each activity to add it to the map
    activities.forEach(activity => {
      let itemAdded = false;
      const popupContent = `<b>${activity.name || 'Unnamed Activity'}</b><br>Type: ${activity.type || activity.sport_type || 'N/A'}`;

      // Attempt to draw polyline if available and decoder loaded
      if (polylineDecoder && activity.summary_polyline) {
        try {
          const latlngs = polylineDecoder(activity.summary_polyline);
          if (latlngs && latlngs.length > 0) {
            L.polyline(latlngs, { color: '#00FF00', weight: 3, opacity: 0.75 }).addTo(featureGroup)
              .bindPopup(popupContent);
            itemAdded = true;
          }
        } catch (decodeError) {
          console.warn(`Could not decode polyline for activity '${activity.name}': ${decodeError}. Falling back to marker if possible.`);
        }
      }

      // If no polyline was added (or couldn't be), try adding a marker if start_latlng exists
      if (!itemAdded && activity.start_latlng && activity.start_latlng.length === 2) {
        L.marker([activity.start_latlng[0], activity.start_latlng[1]], { icon: greenIcon }).addTo(featureGroup)
          .bindPopup(popupContent + (activity.summary_polyline ? "<br><small>(Polyline error)</small>" : ""));
        itemAdded = true;
      }

      if (!itemAdded) {
        console.warn(`Activity '${activity.name}' had no summary_polyline or valid start_latlng. It was not added to the map.`);
      }
    });

    // Add the feature group to the map
    if (featureGroup.getLayers().length > 0) {
      featureGroup.addTo(map);
      try {
        // Adjust map view to fit all items in the feature group
        map.fitBounds(featureGroup.getBounds(), { padding: [40, 40], maxZoom: 15, animate: true });
      } catch (e) {
        console.warn("fitBounds failed. Setting a default view for activities:", e);
        // Fallback if fitBounds fails: use the first activity's coordinates or a wider default.
        const firstGpsActivity = activities.find(act => act.start_latlng && act.start_latlng.length === 2);
        if (firstGpsActivity?.start_latlng) {
             map.setView([firstGpsActivity.start_latlng[0], firstGpsActivity.start_latlng[1]], 13);
        } else {
            map.setView([initialLat, initialLng], initialZoom);
        }
      }
    } else {
      // No activities with GPS data were found or could be processed.
      map.setView([initialLat, initialLng], initialZoom);
      setMapMessage('No activities with displayable GPS data found.', false);
    }

    // Add OpenStreetMap tile layer (Matrix-themed attribution)
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer" style="color:#33FF33;">OpenStreetMap</a> contributors',
      className: 'matrix-tile-layer' // Custom class for potential advanced styling
    }).addTo(map);

    // Style Leaflet's zoom controls if they are part of the map
    if (map.zoomControl) {
      map.zoomControl.getContainer().classList.add('leaflet-control-zoom-matrix');
    }
  });
</script>

<!-- Global Styles for Leaflet elements to match the Matrix theme.
     `is:global` allows these styles to affect Leaflet's dynamically generated HTML. -->
<style is:global>
  .leaflet-popup-content-wrapper,
  .leaflet-popup-tip {
    background: rgba(10, 15, 10, 0.9) !important; /* Dark, slightly transparent green */
    color: #00FF00 !important;
    border: 1px solid rgba(0, 255, 0, 0.7) !important;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.7) !important;
    border-radius: 4px !important;
  }
  .leaflet-popup-content {
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.8rem;
    line-height: 1.4;
  }
  .leaflet-popup-content b { /* Activity Name in Popup */
    color: #88FF88; /* Brighter green for titles */
  }
  .leaflet-popup-content small { /* Subtext in Popup */
    color: #00CC00;
  }
  .leaflet-popup-close-button { /* Close button in popup */
    color: #00FF00 !important;
    background-color: transparent !important;
  }
  .leaflet-popup-close-button:hover {
    color: #FFFFFF !important;
    background-color: #00FF00 !important; /* Green highlight on hover */
  }

  .leaflet-control-attribution { /* Attribution text (bottom-right) */
    background: rgba(0, 10, 0, 0.85) !important;
    color: #00CC00 !important; /* Dim green for less emphasis */
  }
  .leaflet-control-attribution a,
  .leaflet-control-attribution a:hover {
    color: #33FF33 !important; /* Brighter green for links */
  }

  .leaflet-control-zoom-matrix a { /* Zoom control buttons */
    background-color: rgba(10, 15, 10, 0.9) !important;
    color: #00FF00 !important;
    border-color: rgba(0, 255, 0, 0.7) !important;
    border-radius: 3px;
  }
  .leaflet-control-zoom-matrix a:hover {
    background-color: #003300 !important; /* Darker green on hover */
    color: #88FF88 !important;
  }

  .map-container-matrix { /* Ensure the map container itself clips content like border-radius */
    overflow: hidden;
  }

  .map-loading-message { /* Style for the loading/status message inside map div */
    font-family: 'Courier New', Courier, monospace;
    animation: matrixPulseText 1.5s infinite ease-in-out;
  }

  @keyframes matrixPulseText {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* Optional: Styling for map tiles for a more "matrix" feel.
     This can impact performance and readability. Use with caution. */
  .matrix-tile-layer .leaflet-tile {
    /* filter: brightness(0.8) hue-rotate(90deg) sepia(20%) contrast(1.2); */
  }
</style>
