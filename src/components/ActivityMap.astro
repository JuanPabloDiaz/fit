---
import type { StravaActivity } from '@services/stravaService';

// Props interface defines what data the component expects.
// `activities` should be an array of StravaActivity objects.
// `height` is an optional string to set the map's height.
export interface Props {
  activities: StravaActivity[]; // Ensure this matches the type from stravaService.ts
  height?: string;
}

// Destructure props with default values.
const { activities, height = '500px' } = Astro.props;

// Generate a unique ID for the map div. This is crucial if multiple maps
// could appear on the same page, preventing ID collisions.
const mapId = `leaflet-map-${Math.random().toString(36).substring(2, 9)}`;
---

<!-- Leaflet CSS: Fetches the necessary stylesheet for Leaflet from a CDN. -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

<!-- Leaflet JavaScript: Fetches the Leaflet library from a CDN.
     `is:inline` tells Astro to inline this script, ensuring `L` (Leaflet global)
     is available when the component's main script runs. -->
<script is:inline src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<!-- Map Container Div: This is where the Leaflet map will be rendered.
     The `id` is dynamic (using `mapId`) and inline styles set its height and a basic matrix theme. -->
<div
  id={mapId}
  style={`height: ${height}; width: 100%; border: 1px solid rgba(0, 255, 0, 0.3); border-radius: 6px; background: #0D0D0D;`}
  class="map-container-matrix"
  data-map-id={mapId}
  data-activities={JSON.stringify(activities)}
>
  <!-- Fallback/Loading Message: Displayed while the map is initializing or if there's an error. -->
  <p style="color: #00ff00; text-align: center; padding-top: 20px;" class="map-loading-message">Initializing Geospatial Interface...</p>
</div>

<!-- Client-Side Script: This script handles the map initialization and interaction. -->
<script>
  /// <reference types="leaflet" />
  // Explicitly declare the L global variable with its type for TypeScript
  declare var L: typeof import('leaflet');

  // Simple polyline decoder function as fallback
  function decodePolyline(encoded: string): [number, number][] {
    if (!encoded || encoded.length === 0) {
      console.log('Empty or null polyline string');
      return [];
    }

    const poly = [];
    let index = 0;
    const len = encoded.length;
    let lat = 0;
    let lng = 0;

    try {
      while (index < len) {
        let b;
        let shift = 0;
        let result = 0;
        do {
          b = encoded.charCodeAt(index++) - 63;
          result |= (b & 0x1f) << shift;
          shift += 5;
        } while (b >= 0x20);
        const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
        lat += dlat;

        shift = 0;
        result = 0;
        do {
          b = encoded.charCodeAt(index++) - 63;
          result |= (b & 0x1f) << shift;
          shift += 5;
        } while (b >= 0x20);
        const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));
        lng += dlng;

        poly.push([lat / 1e5, lng / 1e5]);
      }
      console.log(`Decoded polyline: ${poly.length} points from ${encoded.length} characters`);
      return poly;
    } catch (error) {
      console.error('Error decoding polyline:', error);
      return [];
    }
  }

  // Function to format distance
  function formatDistance(meters: number): string {
    if (meters >= 1000) {
      return `${(meters / 1000).toFixed(2)} km`;
    }
    return `${Math.round(meters)} m`;
  }

  // Function to calculate distance between two points (Haversine formula)
  function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const R = 6371000; // Earth's radius in meters
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  // Function to initialize the map
  async function initializeMap(mapContainerElement: HTMLElement) {
    const mapIdFromData = mapContainerElement.dataset.mapId;
    const activitiesString = mapContainerElement.dataset.activities;

    if (!mapIdFromData) {
      console.error('data-map-id attribute is missing or empty on map container.');
      return;
    }

    const mapElement = document.getElementById(mapIdFromData); // Get the actual map div by its ID
    const loadingMessageElement = mapElement?.querySelector('.map-loading-message') as HTMLElement | null;

    // Helper to update loading/error message
    const setMapMessage = (message: string, isError: boolean = false) => {
      if (loadingMessageElement) {
        loadingMessageElement.textContent = message;
        loadingMessageElement.style.color = isError ? 'red' : '#00ff00';
        loadingMessageElement.style.display = 'block';
      }
      if (isError) console.error(message);
    };

    if (!mapElement) {
      setMapMessage(`Critical Error: Map element with ID '${mapIdFromData}' not found.`, true);
      return;
    }

    if (typeof L === 'undefined') {
      setMapMessage('Critical Error: Leaflet library (L) not found. Ensure it is loaded.', true);
      return;
    }

    setMapMessage('Decoding activity routes...', false);

    let activities: any[] = [];
    try {
      activities = JSON.parse(activitiesString || '[]');
    } catch (e) {
      setMapMessage('Error: Could not parse activity data.', true);
      console.error('Error parsing activities data from data-activities attribute:', e);
      return;
    }

    // Try to load external polyline library, fallback to built-in decoder
    let polylineDecoder: ((encoded: string) => [number, number][]) | undefined;
    let simplify: ((points: { x: number; y: number }[], tolerance?: number, highestQuality?: boolean) => { x: number; y: number }[]) | undefined;

    try {
      const polylineModule = await import('@mapbox/polyline');
      const decoder = polylineModule.default?.decode || polylineModule.decode;
      if (typeof decoder === 'function') {
        polylineDecoder = decoder;
        console.log('Using @mapbox/polyline decoder');
      }
    } catch (e) {
      console.warn('Could not load @mapbox/polyline, using fallback decoder:', e);
    }

    // Use fallback decoder if external library failed
    if (!polylineDecoder) {
      polylineDecoder = decodePolyline;
      console.log('Using built-in polyline decoder');
    }

    try {
      const simplifyJsModule = await import('simplify-js');
      if (typeof simplifyJsModule.default === 'function') {
        simplify = simplifyJsModule.default;
      } else if (typeof simplifyJsModule === 'function') {
        simplify = simplifyJsModule;
      }
      console.log('Simplify-js loaded successfully');
    } catch (e: any) {
      console.warn('Could not load simplify-js library. Routes will not be simplified:', e);
    }

    if (loadingMessageElement) loadingMessageElement.style.display = 'none';

    let initialLat = 20;
    let initialLng = 0;
    let initialZoom = 2;

    const map = L.map(mapIdFromData);
    const featureGroup = L.featureGroup();

    const activityTypeColors = {
      'Run': '#00FF00',
      'Ride': '#00FFFF',
      'Swim': '#0000FF',
      'Walk': '#FFFF00',
      'Hike': '#FFA500',
      'VirtualRide': '#FF00FF',
      'Workout': '#FF6600',
      'Default': '#FF00FF'
    };

    // Custom icons for start and end points
    const startIcon = L.icon({
        iconUrl: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="%2300FF00" width="20" height="20"><circle cx="10" cy="10" r="8" stroke="%23000" stroke-width="2"/><text x="10" y="14" text-anchor="middle" fill="%23000" font-size="10" font-weight="bold">S</text></svg>',
        iconSize: [20, 20],
        iconAnchor: [10, 10],
        popupAnchor: [0, -10]
    });

    const endIcon = L.icon({
        iconUrl: 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="%23FF0000" width="20" height="20"><circle cx="10" cy="10" r="8" stroke="%23000" stroke-width="2"/><text x="10" y="14" text-anchor="middle" fill="%23FFF" font-size="10" font-weight="bold">F</text></svg>',
        iconSize: [20, 20],
        iconAnchor: [10, 10],
        popupAnchor: [0, -10]
    });

    activities.forEach((activity, index) => {
      console.log(`\n=== Processing Activity ${index + 1}: "${activity.name}" ===`);
      console.log('Activity Type:', activity.type || activity.sport_type);
      console.log('Has summary_polyline:', !!activity.summary_polyline);
      console.log('Polyline length:', activity.summary_polyline ? activity.summary_polyline.length : 0);
      console.log('Start coordinates:', activity.start_latlng);
      console.log('End coordinates:', activity.end_latlng);
      console.log('Distance:', activity.distance);

      let itemAdded = false;
      const activityType = activity.type || activity.sport_type || 'Default';
      const selectedColor = activityTypeColors[activityType] || activityTypeColors['Default'];

      // Base popup content
      let popupContent = `<b>${activity.name || 'Unnamed Activity'}</b><br>`;
      popupContent += `Type: ${activityType}<br>`;

      // Add distance if available
      if (activity.distance) {
        popupContent += `Distance: ${formatDistance(activity.distance)}<br>`;
      }

      // Add moving time if available
      if (activity.moving_time) {
        const hours = Math.floor(activity.moving_time / 3600);
        const minutes = Math.floor((activity.moving_time % 3600) / 60);
        if (hours > 0) {
          popupContent += `Time: ${hours}h ${minutes}m<br>`;
        } else {
          popupContent += `Time: ${minutes}m<br>`;
        }
      }

      // Try to decode and display the polyline (route)
      if (activity.summary_polyline && activity.summary_polyline.length > 0) {
        console.log('Attempting to decode polyline...');
        try {
          let latlngs = polylineDecoder(activity.summary_polyline);
          console.log('Decoded coordinates:', latlngs.length > 0 ? `${latlngs.length} points` : 'No points');

          if (latlngs && latlngs.length > 1) {
            // Simplify the route if simplify library is available and route is long
            if (simplify && latlngs.length > 50) {
              console.log(`Simplifying route with ${latlngs.length} points...`);
              const pointsToSimplify = latlngs.map(p => ({ x: p[1], y: p[0] }));
              const simplifiedPoints = simplify(pointsToSimplify, 0.0001, true);
              latlngs = simplifiedPoints.map(p => [p.y, p.x]);
              console.log(`Simplified to ${latlngs.length} points`);
            }

            // Add the route polyline
            console.log('Adding polyline to map...');
            const polyline = L.polyline(latlngs, {
              color: selectedColor,
              weight: 4,
              opacity: 0.8,
              smoothFactor: 1.0
            }).addTo(featureGroup);

            polyline.bindPopup(popupContent + `<small>Route: ${latlngs.length} points</small>`);

            // Add start marker
            const startPoint = latlngs[0];
            console.log('Adding start marker at:', startPoint);
            L.marker(startPoint, { icon: startIcon })
              .addTo(featureGroup)
              .bindPopup(`<b>🚀 Start</b><br>${activity.name || 'Activity'}<br>Type: ${activityType}`);

            // Add end marker (only if different from start)
            const endPoint = latlngs[latlngs.length - 1];
            const distance = calculateDistance(startPoint[0], startPoint[1], endPoint[0], endPoint[1]);
            console.log(`Distance between start and end: ${distance}m`);

            if (distance > 50) { // Only add end marker if it's more than 50m from start
              console.log('Adding end marker at:', endPoint);
              L.marker(endPoint, { icon: endIcon })
                .addTo(featureGroup)
                .bindPopup(`<b>🏁 Finish</b><br>${activity.name || 'Activity'}<br>Type: ${activityType}`);
            } else {
              console.log('Start and end too close, skipping end marker');
            }

            itemAdded = true;
            console.log(`✅ Successfully added complete route for "${activity.name}"`);

          } else if (latlngs && latlngs.length === 1) {
            // Single point activity
            console.log('Single point activity, adding marker');
            L.marker(latlngs[0], { icon: startIcon })
              .addTo(featureGroup)
              .bindPopup(popupContent + '<small>(Single point activity)</small>');
            itemAdded = true;
          } else {
            console.log('❌ Polyline decoded but no valid points found');
          }
        } catch (decodeError) {
          console.error(`❌ Failed to decode polyline for "${activity.name}":`, decodeError);
        }
      } else {
        console.log('No polyline data available');
      }

      // Fallback to start coordinates if polyline failed or doesn't exist
      if (!itemAdded && activity.start_latlng && Array.isArray(activity.start_latlng) && activity.start_latlng.length === 2) {
        console.log('Using fallback start coordinates:', activity.start_latlng);
        const marker = L.marker([activity.start_latlng[0], activity.start_latlng[1]], { icon: startIcon })
          .addTo(featureGroup);

        let fallbackPopup = popupContent;
        if (activity.summary_polyline) {
          fallbackPopup += '<small>(Route decode failed - showing start only)</small>';
        } else {
          fallbackPopup += '<small>(No route data - showing start only)</small>';
        }

        marker.bindPopup(fallbackPopup);
        itemAdded = true;
        console.log(`⚠️ Added start marker only for "${activity.name}"`);
      }

      // Final fallback - try end coordinates
      if (!itemAdded && activity.end_latlng && Array.isArray(activity.end_latlng) && activity.end_latlng.length === 2) {
        console.log('Using fallback end coordinates:', activity.end_latlng);
        L.marker([activity.end_latlng[0], activity.end_latlng[1]], { icon: endIcon })
          .addTo(featureGroup)
          .bindPopup(popupContent + '<small>(Showing end point only)</small>');
        itemAdded = true;
        console.log(`⚠️ Added end marker only for "${activity.name}"`);
      }

      if (!itemAdded) {
        console.warn(`❌ Activity "${activity.name}" could not be displayed - no valid GPS data found`);
        console.log('Available data:', {
          summary_polyline: !!activity.summary_polyline,
          start_latlng: activity.start_latlng,
          end_latlng: activity.end_latlng
        });
      }

      console.log(`=== End Processing Activity ${index + 1} ===\n`);
    });

    // Fit map to show all activities
    if (featureGroup.getLayers().length > 0) {
      featureGroup.addTo(map);
      try {
        map.fitBounds(featureGroup.getBounds(), {
          padding: [20, 20],
          maxZoom: 15,
          animate: true
        });
      } catch (e) {
        console.warn("fitBounds failed. Setting default view:", e);
        const firstGpsActivity = activities.find(act =>
          (act.start_latlng && act.start_latlng.length === 2) ||
          (act.end_latlng && act.end_latlng.length === 2)
        );
        if (firstGpsActivity?.start_latlng) {
          map.setView([firstGpsActivity.start_latlng[0], firstGpsActivity.start_latlng[1]], 13);
        } else if (firstGpsActivity?.end_latlng) {
          map.setView([firstGpsActivity.end_latlng[0], firstGpsActivity.end_latlng[1]], 13);
        } else {
          map.setView([initialLat, initialLng], initialZoom);
        }
      }
    } else {
      map.setView([initialLat, initialLng], initialZoom);
      setMapMessage('No activities with displayable GPS data found.', false);
    }

    // Add map tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer" style="color:#33FF33;">OpenStreetMap</a> contributors',
      className: 'matrix-tile-layer'
    }).addTo(map);

    // Style zoom controls
    if (map.zoomControl) {
      const zoomContainer = map.zoomControl.getContainer();
      if (zoomContainer) {
        zoomContainer.classList.add('leaflet-control-zoom-matrix');
      }
    }

    console.log(`\n🗺️ Map initialized with ${featureGroup.getLayers().length} elements from ${activities.length} activities`);
    console.log('Activities data preview:');
    activities.forEach((act, i) => {
      console.log(`${i+1}. "${act.name}" - Type: ${act.type || act.sport_type} - Polyline: ${act.summary_polyline ? act.summary_polyline.substring(0, 20) + '...' : 'None'}`);
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    const mapContainers = document.querySelectorAll('.map-container-matrix[data-map-id]') as NodeListOf<HTMLElement>;

    if (mapContainers.length === 0) {
      console.warn('No map containers found on this page.');
      return;
    }

    const observerCallback = (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const mapContainerElement = entry.target as HTMLElement;
          const loadingMessageElement = mapContainerElement.querySelector('.map-loading-message') as HTMLElement | null;
          if (loadingMessageElement) {
            loadingMessageElement.textContent = 'Loading map data...';
          }

          initializeMap(mapContainerElement);
          observer.unobserve(mapContainerElement); // Unobserve after initializing
        }
      });
    };

    const observerOptions = {
      root: null, // relative to document viewport
      rootMargin: '0px',
      threshold: 0.1 // visible amount of item before callback is run
    };

    const observer = new IntersectionObserver(observerCallback, observerOptions);
    mapContainers.forEach(container => {
      const loadingMessageElement = container.querySelector('.map-loading-message') as HTMLElement | null;
      if (loadingMessageElement) {
        loadingMessageElement.textContent = 'Map is waiting to be visible...';
      }
      observer.observe(container);
    });
  });
</script>

<!-- Global Styles for Leaflet elements to match the Matrix theme.
     `is:global` allows these styles to affect Leaflet's dynamically generated HTML. -->
<style is:global>
  .leaflet-popup-content-wrapper,
  .leaflet-popup-tip {
    background: rgba(10, 15, 10, 0.9) !important; /* Dark, slightly transparent green */
    color: #00FF00 !important;
    border: 1px solid rgba(0, 255, 0, 0.7) !important;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.7) !important;
    border-radius: 4px !important;
  }
  .leaflet-popup-content {
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.8rem;
    line-height: 1.4;
  }
  .leaflet-popup-content b { /* Activity Name in Popup */
    color: #88FF88; /* Brighter green for titles */
  }
  .leaflet-popup-content small { /* Subtext in Popup */
    color: #00CC00;
  }
  .leaflet-popup-close-button { /* Close button in popup */
    color: #00FF00 !important;
    background-color: transparent !important;
  }
  .leaflet-popup-close-button:hover {
    color: #FFFFFF !important;
    background-color: #00FF00 !important; /* Green highlight on hover */
  }

  .leaflet-control-attribution { /* Attribution text (bottom-right) */
    background: rgba(0, 10, 0, 0.85) !important;
    color: #00CC00 !important; /* Dim green for less emphasis */
  }
  .leaflet-control-attribution a,
  .leaflet-control-attribution a:hover {
    color: #33FF33 !important; /* Brighter green for links */
  }

  .leaflet-control-zoom-matrix a { /* Zoom control buttons */
    background-color: rgba(10, 15, 10, 0.9) !important;
    color: #00FF00 !important;
    border-color: rgba(0, 255, 0, 0.7) !important;
    border-radius: 3px;
  }
  .leaflet-control-zoom-matrix a:hover {
    background-color: #003300 !important; /* Darker green on hover */
    color: #88FF88 !important;
  }

  .map-container-matrix { /* Ensure the map container itself clips content like border-radius */
    overflow: hidden;
  }

  .map-loading-message { /* Style for the loading/status message inside map div */
    font-family: 'Courier New', Courier, monospace;
    animation: matrixPulseText 1.5s infinite ease-in-out;
  }

  @keyframes matrixPulseText {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }

  /* Optional: Styling for map tiles for a more "matrix" feel.
     This can impact performance and readability. Use with caution. */
  .matrix-tile-layer .leaflet-tile {
    filter: invert(1) hue-rotate(180deg) brightness(0.8) contrast(1.2);
  }
</style>